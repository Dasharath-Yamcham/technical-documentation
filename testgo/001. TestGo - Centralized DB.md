# 001: Centralized TestGo Platform Architecture & Database Strategy

- **Status**: Draft  
- **Date**: 2025-12-11  
- **Owner**: Sai Durga Masabattula
- **Systems in Scope**:  
  1. TestGo Client  
  2. TestGo Labs (LIS)  
  3. TestGo Admin (Unified Admin Portal with RBAC)  
  4. MLX Phlebo App  
  5. Future EMR Application  
  6. Existing LabSquire LIS (to be sunset in phases)

---

## 1. Context

Today, our ecosystem is split across multiple applications and databases:

- **TestGo Client** – Used by providers/clients to place lab orders and view results.  
- **MLX Phlebo App** – Used by phlebotomists to manage sample collections, trips, and order status updates.  
- **MLX Admin / TestGo Admin** – Internal admin tools for operations and support.  
- **LabSquire LIS** – Existing US LIS platform, with:
  - Very large and complex database
  - Significant amount of unused / dead / unreachable code
  - UI and backend that are hard to maintain and risky to refactor

Additionally:

- The **Indian lab flows** and the **US LabSquire flows** are functionally quite different.
- Each system currently maintains its **own database**, which leads to:
  - Duplicate and inconsistent data
  - Complex, fragile data sync logic between systems
  - Stale data and reconciliation issues
  - Difficulty in reporting, auditing, and scaling to new labs and geographies

We want to evolve towards a **TestGo platform** that:

- Can support both **India** and **US** workflows.
- Allows us to deliver **any product independently** (Client portal, Phlebo app, Admin portal, LIS) as a service to customers.
- Is **easier to scale** per customer / per environment (e.g., each client can have their own infrastructure, branding, and configuration).

Rewriting or deeply refactoring the existing **LabSquire** stack (UI + backend + DB) is **not realistic** due to its size, complexity, and technical debt.

So we are choosing a different path.

---

## 2. Decision (High-Level)

We will:

1. **Introduce a Centralized Database (Central DB) as the single source of truth**  
   - All core business data will live here:
     - Orders and test information  
     - Results and report links  
     - Patients and their addresses  
     - Facilities and physicians  
     - Insurance  
     - Phlebotomy data (phlebo users, shifts, trip metrics, order status history)  
     - Lab configuration, ICD codes, tube mappings, etc.

2. **Connect all key applications to this Central DB**  
   - **TestGo Client**  
   - **TestGo Labs (new LIS platform)**  
   - **TestGo Admin** (unified admin portal with role-based access control)  
   - **MLX Phlebo App**  
   - **Future EMR application** (to place orders and pull results)

3. **Keep LabSquire as an external system temporarily**  
   - Central DB will send orders to LabSquire while we still use it.  
   - When LabSquire finishes testing and generates results, those results will be synced back into Central DB.  
   - Over time, **TestGo Labs** will replace LabSquire, and LabSquire will be sunset in phases.

4. **Build a Single Unified Admin Portal (TestGo Admin)**  
   - A single admin application, powered by Central DB, will manage:
     - Orders  
     - Patients and facilities  
     - Labs and configurations  
     - Phlebotomy operations  
   - RBAC (Role-Based Access Control) will ensure each user sees only what they are allowed to see.

5. **Standardize the Database Technology on MongoDB (NoSQL)**  
   - Central DB will be implemented on **MongoDB** (NoSQL).  
   - Existing MLX components that are currently on **PostgreSQL** will be migrated to MongoDB.  
   - LabSquire’s DB remains separate and is integrated via services and sync mechanisms (not shared tables).

---

## 3. Scope

### In Scope

- **Applications**
  - TestGo Client
  - TestGo Labs (new LIS)
  - TestGo Admin (unified, with RBAC)
  - MLX Phlebo app
  - Future EMR

- **Core data domains to be centralized (TestGo Client and MLX) still evolving**
  - Orders (including test data and test-table)  
  - Results (including `REPORT_URL` or equivalent report link)  
  - Insurance  
  - Users (Patients)  
  - UserAddress  
  - Facilities (hospitals)  
  - Physicians (providers)  
  - Physicians_Facilities_Mapping (if needed)  
  - Phlebo_Users  
  - Phlebo_shift_logs  
  - phlebo_trip_metrics (order_id, phlebo_id)  
  - Order_Status_History (orderId)  
  - test_tube_mapping  
  - tube_data_table  
  - icd_codes (for billing, based on case_type)  
  - Labs (lab_code: initially a few records, but extendable)

- **Integration with LabSquire**
  - Syncing orders from Central DB to LabSquire.
  - Syncing results from LabSquire back to Central DB.
  - Supporting both systems during the transition.

### Out of Scope (for this ADR)

- Detailed API specifications and payload formats.
- Detailed UI/UX design for any of the apps.
- Exact MongoDB collection schemas or field structures.
- Low-level performance tuning and infrastructure setup.
- Detailed data migration scripts (covered in a separate technical plan).

---

## 4. High-Level Architecture (Conceptual)

At a high level:

- All **new** and **modernized** apps (TestGo Client, TestGo Labs, TestGo Admin, MLX Phlebo, EMR ) will use **Central DB** as their primary data source.
- **LabSquire** will be treated as an **external system** that:
  - Receives orders from Central DB.
  - Sends results back to Central DB.

Visually, the flow is:

1. **Orders & Patient Data Flow**
   - TestGo Client / EMR / Admin → Central DB → (if needed) LabSquire / TestGo Labs.

2. **Results Flow**
   - LabSquire / TestGo Labs → Central DB → TestGo Client / EMR / Admin.

3. **Phlebotomy Flow**
   - MLX Phlebo App → Central DB (updates on collection status, trips, etc.)
   - Admin and operations teams view this information via TestGo Admin.

Central DB becomes the **one-stop shop** for all critical information.

---

## 5. Why a Centralized DB?

**Current Problem:**  
Each system has its own data store. This causes:

- **Duplicate data**: The same patient or order is stored differently in multiple places.  
- **Stale and inconsistent data**: One system may update a record while others don’t.  
- **Complex sync logic**: We rely on manual reconciliation, exports, ad-hoc scripts, and fragile integrations.  
- **Reporting difficulties**: Building unified reports across systems is slow and painful.

**With Central DB:**

- There is **exactly one source of truth** for orders, results, and key entities.
- All applications **read and write to the same core data**.
- Syncing and reporting become **simpler and more reliable**.
- There is **less duplication** and **less risk of conflicting information**.

---

## 6. Why We Chose MongoDB (NoSQL) over PostgreSQL (SQL)

We considered both a traditional relational database (e.g., PostgreSQL) and a NoSQL database (MongoDB).  
For this platform, we are choosing **MongoDB** as the main technology for Central DB.

### 6.1 Practical Reasons for MongoDB in Our Context

1. **Flexible data model for evolving workflows**  
   - Our lab workflows differ between **India** and **US** and will continue to evolve.
   - Orders can have different shapes (different tests, panels, logistics details) across labs.
   - MongoDB’s document model allows us to store these variations **without constant schema migrations**.
   - This lets us move faster as we refine and expand TestGo Labs and new case types.

2. **Natural fit for “order-centric” documents**  
   - An order often comes with:
     - Patient information
     - Facility and physician details
     - Multiple test items
     - Phlebotomy details
     - Status history
   - In MongoDB, we can store related data together as a **single document or nested structure**, which:
     - Simplifies reads for most use cases (fetch one document instead of many table joins).
     - Is easier to cache and reason about, especially for mobile and client apps.

3. **Scalability and multi-tenant readiness**  
   - Our vision is to:
     - Offer TestGo components as independent services to different clients.
     - Potentially host **separate environments per client** (with their own compute and DB).
   - MongoDB is well-suited for:
     - Horizontal scaling as data volume grows.
     - Partitioning or separating client data by cluster / database / collection.

4. **Migration path for MLX and future services**  
   - MLX phase one uses PostgreSQL and stored procedures.
   - Over time, we’ll move MLX data into MongoDB so everything is aligned.
   - After migration, we will not be split between two primary database technologies.

5. **Developer productivity and faster iteration**  
   - For rapidly changing products (new tests, new labs, new flows), MongoDB avoids frequent schema migrations.
   - This reduces friction for the engineering teams and allows quicker experimentation and rollout.

### 6.2 What About PostgreSQL?

PostgreSQL is a very strong relational database and **could** do this job.  
However, for this project specifically:

- Our data is **highly nested and evolving** (especially orders and lab workflows).
- We want **less rigid schema evolution** and faster iteration cycles.
- We are moving away from **heavy reliance on stored procedures**, which we already see as a maintenance burden in MLX and LabSquire.

Therefore, while PostgreSQL is reliable and mature, **MongoDB better matches our current and future needs** for:

- Flexibility  
- Speed of change  
- Order-centric data model  
- Multi-lab, multi-tenant scenarios

---

## 7. LabSquire Strategy (Support Now, Sunset Later)

### 7.1 Short–Mid Term

- **LabSquire stays live** while we build and roll out TestGo Labs.
- Central DB will:

  1. Receive orders from TestGo Client / EMR / Admin.
  2. Decide where to send them (LabSquire or TestGo Labs).
  3. Push orders to LabSquire when required.
  4. Receive results from LabSquire and store them in Central DB, including the report links.

- For syncing data with LabSquire, we will prefer:

  - **Service-based integrations / webhooks** over direct DB triggers.
    - Example options:
      - Central DB → “Order Sync Service” → LabSquire API
      - LabSquire → Webhook/notification → “Result Ingestion Service” → Central DB

- We want to **avoid tight coupling at the database layer** (e.g., cross-DB triggers), because:
  - It is fragile and hard to monitor.
  - It makes fault isolation and debugging more difficult.
  - It ties us strongly to LabSquire’s internal schema.

### 7.2 Long Term

- As TestGo Labs matures and can cover all required functionality:
  - We will **reduce** the dependency on LabSquire.
  - New orders and workflows will be routed to TestGo Labs instead of LabSquire.
  - LabSquire will be gradually **sunset**.
- Ultimately, TestGo Labs and Central DB will become the **primary platform** for both US and India labs.

---

## 8. Unified Admin Portal (TestGo Admin) with RBAC

We will build a **single unified admin portal**, called **TestGo Admin**, which will:

- Connect to Central DB.
- Provide screens for:
  - Orders and results
  - Patient and facility management
  - Labs and configuration
  - Phlebo operations and metrics
- Implement **RBAC (Role-Based Access Control)** so we can safely:
  - Give different roles to operations, lab staff, support, and client admins.
  - Ensure users only see and manage the data they are permitted to.

This reduces the current fragmentation where multiple admin tools exist and each has a partial view of the system.

---

## 9. MLX PostgreSQL → MongoDB Migration (High-Level, Non-Technical)

MLX phase-one currently:

- Uses **PostgreSQL** as its database.
- Heavily relies on **stored procedures** in the database.
- Has backend and frontend code that expects PostgreSQL schemas.

Our migration plan, at a high level, is:

1. **Design the target MongoDB data model** in Central DB for:
   - Orders
   - Phlebo users
   - Shifts
   - Trip metrics
   - Status history

2. **Extract existing data from PostgreSQL**  
   - Use a **database migration tool** (e.g., DB Gate or similar) to:
     - Export data from PostgreSQL.
     - Transform it into the MongoDB structure.
     - Import it into Central DB.

3. **Refactor MLX backend**  
   - Replace calls to stored procedures with:
     - Application-level logic and MongoDB queries/aggregations.
   - Update APIs to read and write to Central DB (MongoDB) instead of MLX’s local PostgreSQL DB.

4. **Refactor MLX frontend (if needed)**  
   - Ensure the UI works with the updated backend responses.
   - No direct DB awareness in frontend; changes impact response shapes and flows only.

5. **Run MLX in dual-read / shadow mode (if needed)**  
   - For a limited time, we may:
     - Write to MongoDB while still reading from PostgreSQL for comparison.
     - Validate that both systems behave consistently.
   - Once confidence is high, we fully switch to MongoDB.

6. **Decommission MLX PostgreSQL DB**  
   - After a successful migration and stabilization period, we retire the old PostgreSQL database for MLX.

All of this will be captured in a separate **technical migration plan** with detailed steps, checks, and rollback strategies.

---

## 10. Consequences

### 10.1 Positive

- **Single source of truth** for orders, results, and key entities.
- Significant reduction in **duplicate and inconsistent data**.
- Easier **reporting and analytics** across labs, geographies, and products.
- Cleaner path to **sunset LabSquire** and converge on TestGo Labs.
- Ability to deliver:
  - TestGo Client
  - TestGo Labs
  - TestGo Admin
  - MLX Phlebo
  - As independent, branded services per client.
- **Faster iteration** due to MongoDB’s flexible data model.

### 10.2 Negative / Risks

- Central DB becomes a **critical dependency**; outages will affect multiple products (Mitigation: MongoDB Replica Sets to avoid single-node failure)
- MongoDB requires:
  - Proper design for indexing and document modeling to avoid performance issues.
- Migration from existing databases (LabSquire, MLX PostgreSQL) is non-trivial and must be carefully managed.
- Teams familiar with relational databases will need:
  - Time and training to adapt to MongoDB patterns and best practices.

---

## 11. Open Questions

1. **Final hosting model per client**  
   - One cluster per client vs shared cluster with strong isolation?
2. **Exact data contract with LabSquire**  
   - Which fields and formats for order and result exchange?
3. **EMR integration standards**  
   - HL7 vs FHIR vs custom APIs for different EMR partners.
4. **Governance**  
   - Who owns schema and data model changes in Central DB?
5. **Security and compliance**  
   - Detailed approach for PHI protection, auditing, and compliance (HIPAA, etc.).

---

## 12. Summary (For Non-Technical Stakeholders)

- We are **not** going to “clean up” LabSquire’s huge, messy database and codebase.  
- Instead, we are building a **new Central Database on MongoDB** that becomes the **single source of truth** for all important lab data.
- All key apps — TestGo Client, TestGo Labs, TestGo Admin, MLX Phlebo, and future EMR application — will use this Central DB.
- LabSquire will be **supported and integrated** for some time, but eventually **TestGo Labs** will replace it.
- We will **migrate MLX** from PostgreSQL to Central DB (MongoDB) over time, simplifying our technology stack.
- The result is a cleaner, more scalable, and more flexible platform that is easier to manage and grow.

---
